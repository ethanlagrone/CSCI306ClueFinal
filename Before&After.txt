COMMIT 1 BEFORE:

package clueGame;

public enum DoorDirection {
	LEFT, RIGHT, UP, DOWN
}

AFTER:

package clueGame;

public enum DoorDirection {
	NONE, LEFT, RIGHT, UP, DOWN
}

COMMIT 2 BEFORE:

						if(i-1 >= 0 && grid[i-1][j] != null && !grid[i-1][j].isInRoom()) {
	                        cell.addAdjacency(grid[i-1][j]);
	                    }
	                    if(i+1 < numRows && grid[i+1][j] != null && !grid[i+1][j].isInRoom()) {
	                        cell.addAdjacency(grid[i+1][j]);
	                    }
	                    if(j-1 >= 0 && grid[i][j-1] != null && !grid[i][j-1].isInRoom()) {
	                        cell.addAdjacency(grid[i][j-1]);
	                    }
	                    if(j+1 < numCols && grid[i][j+1] != null && !grid[i][j+1].isInRoom()) {
	                        cell.addAdjacency(grid[i][j+1]);
	                    }
	                    
	    			//WALKWAY CELLS THAT ARENT DOORWAYS
	    			} else {
	    				if(i-1 >= 0 && grid[i-1][j] != null && !grid[i-1][j].isInRoom()) {
	                        cell.addAdjacency(grid[i-1][j]);
	                    }
	                    if(i+1 < numRows && grid[i+1][j] != null && !grid[i+1][j].isInRoom()) {
	                        cell.addAdjacency(grid[i+1][j]);
	                    }
	                    if(j-1 >= 0 && grid[i][j-1] != null && !grid[i][j-1].isInRoom()) {
	                        cell.addAdjacency(grid[i][j-1]);
	                    }
	                    if(j+1 < numCols && grid[i][j+1] != null && !grid[i][j+1].isInRoom()) {
	                        cell.addAdjacency(grid[i][j+1]);
	                    }
	    			}
	    			
	    			
AFTER:


						if(i-1 >= 0 && isAdjacentWalkway(grid[i-1][j])) {
	                        cell.addAdjacency(grid[i-1][j]);
	                    }
	                    if(i+1 < numRows && isAdjacentWalkway(grid[i+1][j])) {
	                        cell.addAdjacency(grid[i+1][j]);
	                    }
	                    if(j-1 >= 0 && isAdjacentWalkway(grid[i][j-1])) {
	                        cell.addAdjacency(grid[i][j-1]);
	                    }
	                    if(j+1 < numCols && isAdjacentWalkway(grid[i][j+1])) {
	                        cell.addAdjacency(grid[i][j+1]);
	                    }
	                    
	    			//WALKWAY CELLS THAT ARENT DOORWAYS
	    			} else {
	    				if(i-1 >= 0 && isAdjacentWalkway(grid[i-1][j])) {
	                        cell.addAdjacency(grid[i-1][j]);
	                    }
	                    if(i+1 < numRows && isAdjacentWalkway(grid[i+1][j])) {
	                        cell.addAdjacency(grid[i+1][j]);
	                    }
	                    if(j-1 >= 0 && isAdjacentWalkway(grid[i][j-1])) {
	                        cell.addAdjacency(grid[i][j-1]);
	                    }
	                    if(j+1 < numCols && isAdjacentWalkway(grid[i][j+1])) {
	                        cell.addAdjacency(grid[i][j+1]);
	                    }
	    			}


public boolean isAdjacentWalkway(BoardCell cell) {
 		if(cell != null && !cell.isInRoom()) {
 			return true;
 		} else {
 	 		return false;
 		}
 	}
 	
 	
 	
 	
 	
 COMMIT 3 BEFORE: 
 						if(i-1 >= 0 && isAdjacentWalkway(grid[i-1][j])) {
	                        cell.addAdjacency(grid[i-1][j]);
	                    }
	                    if(i+1 < numRows && isAdjacentWalkway(grid[i+1][j])) {
	                        cell.addAdjacency(grid[i+1][j]);
	                    }
	                    if(j-1 >= 0 && isAdjacentWalkway(grid[i][j-1])) {
	                        cell.addAdjacency(grid[i][j-1]);
	                    }
	                    if(j+1 < numCols && isAdjacentWalkway(grid[i][j+1])) {
	                        cell.addAdjacency(grid[i][j+1]);
	                    }
	                    
	    			//WALKWAY CELLS THAT ARENT DOORWAYS
	    			} else {
	    				if(i-1 >= 0 && isAdjacentWalkway(grid[i-1][j])) {
	                        cell.addAdjacency(grid[i-1][j]);
	                    }
	                    if(i+1 < numRows && isAdjacentWalkway(grid[i+1][j])) {
	                        cell.addAdjacency(grid[i+1][j]);
	                    }
	                    if(j-1 >= 0 && isAdjacentWalkway(grid[i][j-1])) {
	                        cell.addAdjacency(grid[i][j-1]);
	                    }
	                    if(j+1 < numCols && isAdjacentWalkway(grid[i][j+1])) {
	                        cell.addAdjacency(grid[i][j+1]);
	                    }
	    			}
 
 
 
 COMMIT 3 AFTER: 
 //after door direction found, find the other adjacency of the cell
	    				findWalkwayAdjacency(cell, i, j);
	    			//WALKWAY CELLS THAT ARENT DOORWAYS
	    			} else {
	    				findWalkwayAdjacency(cell, i, j);
	    			}
	    			
	    			
	    			heres the helper function:
public void findWalkwayAdjacency(BoardCell cell, int i, int j) {
 		if(i-1 >= 0 && isAdjacentWalkway(grid[i-1][j])) {
            cell.addAdjacency(grid[i-1][j]);
        }
        if(i+1 < numRows && isAdjacentWalkway(grid[i+1][j])) {
            cell.addAdjacency(grid[i+1][j]);
        }
        if(j-1 >= 0 && isAdjacentWalkway(grid[i][j-1])) {
            cell.addAdjacency(grid[i][j-1]);
        }
        if(j+1 < numCols && isAdjacentWalkway(grid[i][j+1])) {
            cell.addAdjacency(grid[i][j+1]);
        }
 	}
 	
 	
 	
 COMMIT 4 BEFORE: 
 						if(currentCell.getRoom().getName().equals("Walkway")) {
							currentCell.setInRoom(false);
						}
						
						//ROOM LOGIC
	    				if(!cell.getRoom().getName().equals("Walkway")) {
	    				
	    				
	    				
COMMIT 4 AFTER:
	if(!isWalkway(cell))
	
	
HELPER
public boolean isWalkway(BoardCell cell) {
 		if(cell.getRoom().getName().equals("Walkway")) {
 			return true;
 		} else {
 			return false;
 		}
 	}
 	
 	
COMMIT 5 BEFORE:
public void initialize() {
    	//makes dummy 4x4 board for BoardTestsExp
    	if(layoutCsv == null || setupTxt == null) {
    		numRows = 4;
    		numCols = 4;
			grid = new BoardCell[numRows][numCols];
    		for(int i = 0; i < numRows; i++) {
    			for(int j = 0; j < numCols; j++) {
    				grid[i][j] = new BoardCell(i, j);
    			}
    		}
    		//putting in old adjacent calcs to keep test consistent
    		for(int i = 0; i < numRows; i++) {
    			for(int j = 0; j < numCols; j++) {
    				BoardCell cell = grid[i][j];		
    				if(i-1 >= 0) {
    					cell.addAdjacency(grid[i-1][j]);
    				}
    				if(i+1 < numRows) {
    					cell.addAdjacency(grid[i+1][j]);
    				}
    				if(j-1 >= 0) {
    					cell.addAdjacency(grid[i][j-1]);
    				}
    				if(j+1 < numCols) {
    					cell.addAdjacency(grid[i][j+1]);
    				}
    			}
    		} 
    	} else {
	    	try {
				loadSetupConfig();
				loadLayoutConfig();
			}
			catch (BadConfigFormatException e) {
				System.out.print(e);
			}
	
			grid = new BoardCell[numRows][numCols];
			
			//setup board with cells
			char roomChar;
			char specialChar;
			for(int i = 0; i < numRows; i++) {
				String cells[] = rows.get(i).split(",");
				for(int j = 0; j < numCols; j++) {
					grid[i][j] = new BoardCell(i, j);
					BoardCell currentCell = grid[i][j];
					roomChar = cells[j].charAt(0);
					
					if (roomMap.containsKey(roomChar)) {
						currentCell.setInRoom(true);
						currentCell.setRoom(roomMap.get(roomChar));
						if(isWalkway(currentCell)) {
							currentCell.setInRoom(false);
						}
						if (cells[j].length() == 2) {
							specialChar = cells[j].charAt(1);
							if (roomMap.containsKey(specialChar)) {
								currentCell.setIsSecretPassage(true);
								currentCell.setSecretPassage(specialChar);
							}
							else {
								switch (specialChar) {
									case '*':
										currentCell.setRoomCenter(true);
										roomMap.get(roomChar).setCenterCell(grid[i][j]);
										break;
									case '#':
										currentCell.setLabel(true);
										roomMap.get(roomChar).setLabelCell(grid[i][j]);
										break;
									case '^':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.UP);
										break;
									case '>':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.RIGHT);
										break;
									case 'v':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.DOWN);
										break;
									case '<':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.LEFT);
										break;
								} 
							}
						}
					}
				}
			}
		}
		
		//find every adjacency of each cell, hint said to do it here
    	//made helper to split up
		try {
			calculateAdjacencies();
		} catch (BadConfigFormatException e) {
			e.printStackTrace();
		}
	}
	
	
	COMMIT 5 AFTER: 
	public void initialize() {
    	//makes dummy 4x4 board for BoardTestsExp
    	if(layoutCsv == null || setupTxt == null) {
    		numRows = 4;
    		numCols = 4;
			grid = new BoardCell[numRows][numCols];
    		for(int i = 0; i < numRows; i++) {
    			for(int j = 0; j < numCols; j++) {
    				grid[i][j] = new BoardCell(i, j);
    			}
    		}
    		//putting in old adjacent calcs to keep test consistent
    		for(int i = 0; i < numRows; i++) {
    			for(int j = 0; j < numCols; j++) {
    				BoardCell cell = grid[i][j];		
    				if(i-1 >= 0) {
    					cell.addAdjacency(grid[i-1][j]);
    				}
    				if(i+1 < numRows) {
    					cell.addAdjacency(grid[i+1][j]);
    				}
    				if(j-1 >= 0) {
    					cell.addAdjacency(grid[i][j-1]);
    				}
    				if(j+1 < numCols) {
    					cell.addAdjacency(grid[i][j+1]);
    				}
    			}
    		} 
    	} else {
    		//load setup files
	    	try {
				loadSetupConfig();
				loadLayoutConfig();
			}
			catch (BadConfigFormatException e) {
				System.out.print(e);
			}
	
			grid = new BoardCell[numRows][numCols];
			
			//setup board with cells
			char roomChar;
			char specialChar;
			for(int i = 0; i < numRows; i++) {
				String cells[] = rows.get(i).split(",");
				for(int j = 0; j < numCols; j++) {
					grid[i][j] = new BoardCell(i, j);
					BoardCell currentCell = grid[i][j];
					roomChar = cells[j].charAt(0);
					//finds if cell is a room and sets it accordingly
					if (roomMap.containsKey(roomChar)) {
						currentCell.setInRoom(true);
						currentCell.setRoom(roomMap.get(roomChar));
						if(isWalkway(currentCell)) {
							currentCell.setInRoom(false);
						}
						//check that there is two characters in a cell to know that the room is special
						if (cells[j].length() == 2) {
							specialChar = cells[j].charAt(1);
							//checks initial char to see if it is another letter making it a secret passage
							if (roomMap.containsKey(specialChar)) {
								currentCell.setIsSecretPassage(true);
								currentCell.setSecretPassage(specialChar);
							}
							else {
								//CHECK SPECIAL CHARACTER AND SET ACCORDINGLY
								switch (specialChar) {
									case '*':
										currentCell.setRoomCenter(true);
										roomMap.get(roomChar).setCenterCell(grid[i][j]);
										break;
									case '#':
										currentCell.setLabel(true);
										roomMap.get(roomChar).setLabelCell(grid[i][j]);
										break;
									case '^':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.UP);
										break;
									case '>':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.RIGHT);
										break;
									case 'v':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.DOWN);
										break;
									case '<':
										currentCell.setDoorway(true);
										currentCell.setDoorDirection(DoorDirection.LEFT);
										break;
								} 
							}
						}
					}
				}
			}
		}
		
		//find every adjacency of each cell, hint said to do it here
    	//made helper to split up
		try {
			calculateAdjacencies();
		} catch (BadConfigFormatException e) {
			e.printStackTrace();
		}
	}